-- Create user/schema
CREATE USER myapp IDENTIFIED BY mypass;
GRANT CONNECT, RESOURCE TO myapp;

ALTER SESSION SET CURRENT_SCHEMA = myapp;
ALTER USER myapp QUOTA UNLIMITED ON users;

-- Drop table if exists (safe re-run)
BEGIN
  EXECUTE IMMEDIATE 'DROP TABLE myapp.profiles';
EXCEPTION
  WHEN OTHERS THEN
    IF SQLCODE != -942 THEN RAISE; END IF;
END;
/

-- Create table with a BLOB field for JSON-like data
CREATE TABLE myapp.profiles (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR2(100),
  json_data BLOB CHECK(json_data IS JSON),  -- <-- This will hold JSON serialized as bytes
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Optional: create a check constraint to ensure json_data is valid JSON text (if stored as CLOB)
-- But since we store as BLOB, validation happens at app level (e.g., in Go code).

-- Insert dummy BLOB data (simulate JSONB-like storage)
DECLARE
  l_json CLOB := '{"name":"alice","age":25,"contacts":{
    "email": "alice@example.com",
    "phone": "+62-812-1234-5678"
  }, "address": {
    "street": "Jl. Merdeka No.10",
    "city": "JKT",
    "postal_code": "13340"
  }}';
  l_blob BLOB;
BEGIN
  DBMS_LOB.createtemporary(l_blob, TRUE);
  DBMS_LOB.converttoblob(
    dest_lob     => l_blob,
    src_clob     => l_json,
    amount       => DBMS_LOB.lobmaxsize,
    dest_offset  => 1,
    src_offset   => 1,
    blob_csid    => DBMS_LOB.default_csid,
    lang_context => 0,
    warning      => 0
  );
  
  INSERT INTO myapp.profiles (name, json_data)
  VALUES ('Alice', l_blob);

  DBMS_LOB.freetemporary(l_blob);
  COMMIT;
END;

CREATE OR REPLACE PROCEDURE myapp.get_all_profiles (
    p_cursor OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN p_cursor FOR
        SELECT
            id,
            name,
            UTL_RAW.CAST_TO_VARCHAR2(json_data) AS json_data,
            created_at
        FROM myapp.profiles;
END get_all_profiles;